Modern C++

Guten Morgen 

Peter Loos

P@ssw0rd

========================

ca 12.30 

9.00 bis 17.00

Coffee-Breaks

========================

https://github.com/pelocpp

Unter-RePo:  Modern Cpp  // cpp_modern <===

========================

Inhalt / Agenda

== Welchen Sprachen kenne ich 
== Was sind meine Erwartungen
== Was MUSS drin sein :)
== Muss nächste Woche Deep C++ programmieren
== Will C++ Quellcode nur lesen / verstehen können
== Rule of Three / Five / Zero


Neue Features
Deep Inside
Ab Funktionale Progr.
Templates
Tipps & Tricks
Exception Safety

========================

Referenz:   Alias für ein Objekt (Name !!!)

Es wird eine Adresse übergeben

Call by Value:   KOPIE

C# / Java:    Referenz-basiert   
              (C# und struct: Value-basiert)

C++:          Referenz-basiert (Adressen)  
              Value-basiert (Kopien)  

C++:  Why  ==> Performanz !!!

C++ 11: 

C - Definition:

x = y;   // 
         // x: Adresse      // Left Value
         // y: Wert (Value) // Right-Value

LValue // Left Value
RValue // Right Value

LValue - Referenzen

RValue - Referenzen.   Why ????????????????

Move-Semantik:

Vergleich:

... 300:   // Temp. Objekt am Stack // Wird freigegeben
... 370:   // Objekt im Vektor

Noch ein Vergleich - ab C++ 11:


... 520:  


============================================

Flache Kopie:   Kann / wird automatisch von C++ unterstützt.

Tiefe Kopie:    Muss dann - vom Entwickler - realisiert werden,
                wenn in der Klasse Zeiger (Heap) vorhanden sind.

... 2F0:

=============================================

C++:

== Objekt-Orientiert   (Bjarne Stroustrup)

== Generische Programmierung (templates ... auto)

   Alexander Stepanov

   STL

=============================================

Lambdas:

== Historische Herleitung

   i)  C-Funktion bei STL_Algorithmen
   ii) Aufrufbares Objekt

== Was ist ein Lambda?


Lambda-Funktion:

C++:  Lambda-Objekt

Wie funktiniert ein  Lambda-Objekt  ???

a) Wir haben eine anonyme, lokale Klasse IN DERSELBEN Methode.

b) Diese überläft den operator()

c) Dieser wird gerufen.

Tool:  Cpp Insights

=============================================

"Exception Safety"

=============================================

Initializer List:  std::initializer_list     Stack

Vektor:            std::vector               Heap

{ 1, 2, 3, 4, 5, 6, 7, 8 } 

Embedded Programming

std::string:      Auf dem Heap : Generell RICHTIG

ABER:             SSO // Small String Optimization


std::vector<int> vec(10);   // 10 Elems, alle vom Wert 0

vs.

std::vector<int> vec{ 10 };  // 1 Element, vom Wert 10


================================================

auto

i)   Vereinbarung von Variablen

ii)  Rückgabetyp von Funktionen

iii) Datentyp für Parameter



Ein Vergleich:

Mit &:

    int tmp = n;
00007FF6F9156B40  mov         rax,qword ptr [n]  
00007FF6F9156B47  mov         eax,dword ptr [rax]  
00007FF6F9156B49  mov         dword ptr [tmp],eax  

Ohne & // Kopie:

    int tmp = n;
00007FF774736B3F  mov         eax,dword ptr [n]  
00007FF774736B45  mov         dword ptr [tmp],eax  


// ==================================================

Was ist das Problem mit new ???  Zeiger

Wer ist der Besitzer (Owner) des Zeigers ???

Wo ist das delete ???

Death March

Idee:

a) Objekt-Orientierung

b) Konstruktoren
   Destruktoren

c) Wann wird der Destruktor aufgerufen?
   Am Ende des Scopes!

d) Determinismus // definiert

e) Man stecke Zeiger (new) in Hüllenobjekte 
   Hüllenklasse:

   Konstruktor  ==> new
   Destruktoren ==> delete

f) auto_ptr:   deprecated

g) std::unique_ptr
   std::shared_ptr / std::weak_ptr

2 Strategien

Besitzer // Owner

i) Ein std::unique_ptr-Objekt hat zu 
   einem Zeitpunkt EINEN Besitzer.

ii) Ein std::shared_ptr-Objekt kann zu 
    einem Zeitpunkt MEHRERE Besitzer haben.
     
     (Smell: C# / Garbage Collection )


// ======================================

Optimierungstechniken
---------------------

RVO

NRVO

Copy and Move Elision

// ======================================

1. Ansatz: 

Go - for - std::unique_ptr oder std::shared_ptr ???

std::unique_ptr  <=== Einfacher 

std::shared_ptr  <=== FUNKTIONIERT NICHT IMMER 

Performanz: Referenzzähler: Thread-Safe?: Ja. 

std::shared_ptr  <=== std::weak_ptr

2 Beispiele:
a) Wie funktioniert der std::weak_ptr
b) Why ???????????????????????????

// =========================================

Zyklische Referenzen:  "Habe ich nicht" :)

Call-to-Action:

Observer - Pattern

a) Klasse Source

   Hat Zustände, die sich ändern.

b) Klassse Client:

   Clients interessieren sich für Änderungen
   am Objekt "Source"

c) Clients wollen informiert werden, wenn
   sich Änderungen am Objekt "Source" ergeben.

   Offensichtlich: Der / die Clients kennen das Source-Objekt.

d) Technische Umsetzung: Clients melden sich am Source Objekt an.
 
    attach // register:

    source.register (client);

e) Ein Source - Objekt muss eine "Liste" verwalten
   für alle Clients, die bei Zustandsänderungen
   informiert werden wollen.

   Offensichtlich: Das Source-Objekt kennt Client-Objekte.

Ansatz:

Source:    std::shared_ptr<Source>

Client(s): std::shared_ptr<Client>

Beobachtung:

Source - Objekt: "Liste" von Client-Objekten // register

 "Liste" <std::shared_ptr>
 oder
 "Liste" <std::weak_ptr>   <=== 

 Eine Source sollte nicht zum BESITZER (Owner)
 eines Clients werden.

 Source: Rückruf // notify erfolgt:

 Client-Weak-Ptr:  Lock.

 if (result == nullptr)  DAMIT MUSS DIE SOURCE
                         UMGEHEN KÖNNEN !!!!

Visualisierung:  Bauteile // Aktien

Ein Bauteil ist nicht mehr vorhanden.

Legacy-Anwendung:  Auf Smart-Pointer umstellen ????

Never touch a running system.

Ein neues Modul: 

Rule-of-Zero:  Smart-Pointer.

[[ likely ]] if (condition) {
   // 90%
}
[[ unlikely ]] else
{
   // 10%
}

===================================================

constexpr

SW:   Globales Datensegment

Tabellen // Strukturen

Deren Information eigentlich schon vorher bekannt ist.

ROM 

===================================================

Literal / Konstante

100

123.345f

123ul

123_km

123_kilogramm

123_kg

123_pound

123.534_pound;

0xFF0000_farbe;

0xFF0000_color;   // Objekte

"13:16:00"_uhrzeit;  // Zeichenkette parsen // RegExpr

"13:16:00"_uhrzeit;  // Zeichenkette parsen // RegExpr

Grammatik  // Syntax // Lexikon

C++  ===> Lexikon erweitern.

Wie ???????????????????????????????

operator ""   Literaloperator

UDL   User Defined Literal

type operator ""  _suffix  (int parameter)

int operator ""  _km  (int parameter)

---------------------------------------

operator ()  // invoke

Methoden tun's auch: 

Richtig - ich muss den Namen der Methode reservieren / festlegen

Iterator:

next()   ++
Current  *
equals   ==, !=

---------------------------------------

Beispiel:

0xFF0000_rgb;   // class Color  // red

123_km

123_m

123_km + 123_m 

123123_rgb ;

"0xFF0000"_rgb;  


===============================================

30 Minuten Übung :)

Smart Pointer

std::weak_ptr 

#include <memory>

===============================================

11: std::shared_ptr<X> pA{ new X{} };    // passt
12: std::shared_ptr<X> pB;
13: std::shared_ptr<X> pC;
14: 
15: pB = pA;                               // passt  - pA, pb: 2
16: pC = std::shared_ptr<X>(pB.get());     // Foul: pC: Hat Raw Pointer von pa, pb
17: pC = nullptr;                          // reset // gibt Raw Pointer frei !!!
18: int value = (*pB).getValue();                   // Falscher Wert
19: std::cout << "Value: " << value << std::endl;   
                                          // Destruktor: pa, pb


========================================================

std::optional

Problem:

int n = 123;

// ist das ein gültiger Wert 

n = 0;

if (n == 0)  

if (n == -1)

if (n == -2234234234)  

int n = 123;   // gültiger Wert
bool isValid = true / false;

// Pointer:

int* pn = NULL;  // malloc / new

C++ Datentyp: ein int und ein bool vereint :)

std::optional <int> 


C#:

int? n;

=============================================================

std::variant

Kann Daten unterschiedlichen Typs aufnehmen ....
zu einem Zeitpunkt aber nur eine Art von Wert.

Die unterschiedlichen Typen müssen VORHER bekannt sein.

std::any 

Excel // Sheets   =========> Zelle 

Zelle // Cell:  Zeichenkette, Wert, Datum, Currency,  ... 

Gaming Board:

Figuren  ===> std::variant

