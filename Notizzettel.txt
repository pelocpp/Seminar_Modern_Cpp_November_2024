Modern C++

Guten Morgen 

Peter Loos

P@ssw0rd

========================

ca 12.30 

9.00 bis 17.00

Coffee-Breaks

========================

https://github.com/pelocpp

Unter-RePo:  Modern Cpp  // cpp_modern <===

========================

Inhalt / Agenda

== Welchen Sprachen kenne ich 
== Was sind meine Erwartungen
== Was MUSS drin sein :)
== Muss nächste Woche Deep C++ programmieren
== Will C++ Quellcode nur lesen / verstehen können
== Rule of Three / Five / Zero


Neue Features
Deep Inside
Ab Funktionale Progr.
Templates
Tipps & Tricks
Exception Safety

========================

Referenz:   Alias für ein Objekt (Name !!!)

Es wird eine Adresse übergeben

Call by Value:   KOPIE

C# / Java:    Referenz-basiert   
              (C# und struct: Value-basiert)

C++:          Referenz-basiert (Adressen)  
              Value-basiert (Kopien)  

C++:  Why  ==> Performanz !!!

C++ 11: 

C - Definition:

x = y;   // 
         // x: Adresse      // Left Value
         // y: Wert (Value) // Right-Value

LValue // Left Value
RValue // Right Value

LValue - Referenzen

RValue - Referenzen.   Why ????????????????

Move-Semantik:

Vergleich:

... 300:   // Temp. Objekt am Stack // Wird freigegeben
... 370:   // Objekt im Vektor

Noch ein Vergleich - ab C++ 11:


... 520:  


============================================

Flache Kopie:   Kann / wird automatisch von C++ unterstützt.

Tiefe Kopie:    Muss dann - vom Entwickler - realisiert werden,
                wenn in der Klasse Zeiger (Heap) vorhanden sind.

... 2F0:

=============================================

C++:

== Objekt-Orientiert   (Bjarne Stroustrup)

== Generische Programmierung (templates ... auto)

   Alexander Stepanov

   STL

=============================================

Lambdas:

== Historische Herleitung

   i)  C-Funktion bei STL_Algorithmen
   ii) Aufrufbares Objekt

== Was ist ein Lambda?


Lambda-Funktion:

C++:  Lambda-Objekt

Wie funktiniert ein  Lambda-Objekt  ???

a) Wir haben eine anonyme, lokale Klasse IN DERSELBEN Methode.

b) Diese überläft den operator()

c) Dieser wird gerufen.

Tool:  Cpp Insights

=============================================

"Exception Safety"

=============================================

Initializer List:  std::initializer_list     Stack

Vektor:            std::vector               Heap

{ 1, 2, 3, 4, 5, 6, 7, 8 } 

Embedded Programming

std::string:      Auf dem Heap : Generell RICHTIG

ABER:             SSO // Small String Optimization


std::vector<int> vec(10);   // 10 Elems, alle vom Wert 0

vs.

std::vector<int> vec{ 10 };  // 1 Element, vom Wert 10


================================================

auto

i)   Vereinbarung von Variablen

ii)  Rückgabetyp von Funktionen

iii) Datentyp für Parameter



Ein Vergleich:

Mit &:

    int tmp = n;
00007FF6F9156B40  mov         rax,qword ptr [n]  
00007FF6F9156B47  mov         eax,dword ptr [rax]  
00007FF6F9156B49  mov         dword ptr [tmp],eax  

Ohne & // Kopie:

    int tmp = n;
00007FF774736B3F  mov         eax,dword ptr [n]  
00007FF774736B45  mov         dword ptr [tmp],eax  


// ==================================================

Was ist das Problem mit new ???  Zeiger

Wer ist der Besitzer (Owner) des Zeigers ???

Wo ist das delete ???

Death March

Idee:

a) Objekt-Orientierung

b) Konstruktoren
   Destruktoren

c) Wann wird der Destruktor aufgerufen?
   Am Ende des Scopes!

d) Determinismus // definiert

e) Man stecke Zeiger (new) in Hüllenobjekte 
   Hüllenklasse:

   Konstruktor  ==> new
   Destruktoren ==> delete

f) auto_ptr:   deprecated

g) std::unique_ptr
   std::shared_ptr / std::weak_ptr

2 Strategien

Besitzer // Owner

i) Ein std::unique_ptr-Objekt hat zu 
   einem Zeitpunkt EINEN Besitzer.

ii) Ein std::shared_ptr-Objekt kann zu 
    einem Zeitpunkt MEHRERE Besitzer haben.
     
     (Smell: C# / Garbage Collection )


// ======================================

Optimierungstechniken
---------------------

RVO

NRVO

Copy and Move Elision

// ======================================

1. Ansatz: 

Go - for - std::unique_ptr oder std::shared_ptr ???

std::unique_ptr  <=== Einfacher 

std::shared_ptr  <=== FUNKTIONIERT NICHT IMMER 

Performanz: Referenzzähler: Thread-Safe?: Ja. 

std::shared_ptr  <=== std::weak_ptr

2 Beispiele:
a) Wie funktioniert der std::weak_ptr
b) Why ???????????????????????????

// =========================================

Zyklische Referenzen:  "Habe ich nicht" :)

Call-to-Action:

Observer - Pattern

a) Klasse Source

   Hat Zustände, die sich ändern.

b) Klassse Client:

   Clients interessieren sich für Änderungen
   am Objekt "Source"

c) Clients wollen informiert werden, wenn
   sich Änderungen am Objekt "Source" ergeben.

   Offensichtlich: Der / die Clients kennen das Source-Objekt.

d) Technische Umsetzung: Clients melden sich am Source Objekt an.
 
    attach // register:

    source.register (client);

e) Ein Source - Objekt muss eine "Liste" verwalten
   für alle Clients, die bei Zustandsänderungen
   informiert werden wollen.

   Offensichtlich: Das Source-Objekt kennt Client-Objekte.

Ansatz:

Source:    std::shared_ptr<Source>

Client(s): std::shared_ptr<Client>

Beobachtung:

Source - Objekt: "Liste" von Client-Objekten // register

 "Liste" <std::shared_ptr>
 oder
 "Liste" <std::weak_ptr>   <=== 

 Eine Source sollte nicht zum BESITZER (Owner)
 eines Clients werden.

 Source: Rückruf // notify erfolgt:

 Client-Weak-Ptr:  Lock.

 if (result == nullptr)  DAMIT MUSS DIE SOURCE
                         UMGEHEN KÖNNEN !!!!

Visualisierung:  Bauteile // Aktien

Ein Bauteil ist nicht mehr vorhanden.

Legacy-Anwendung:  Auf Smart-Pointer umstellen ????

Never touch a running system.

Ein neues Modul: 

Rule-of-Zero:  Smart-Pointer.

[[ likely ]] if (condition) {
   // 90%
}
[[ unlikely ]] else
{
   // 10%
}